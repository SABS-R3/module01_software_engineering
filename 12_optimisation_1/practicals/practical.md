---
title: Optimisation 1 - Numpy vectorisation and Cython
geometry: margin=3cm
urlcolor: blue
link-citations: true
---

\newcommand{\ud}{\mathrm{d}}
\newcommand{\bfx}{{\bf x}}
\newcommand{\bfp}{{\bf p}}
\newcommand{\bfX}{{\bf X}}


# Cell model

This practical uses a model of cell diffusion and excluded volume interaction. A brief 
description of the model is given below, although it is not required that you understand 
the details of the model, as it is implemented for you in
the python module contain in the `cell_model` directory. The purpose of this practical
is to profile and increase the efficiency of the model using numpy vectorisation and
C++.

The model consists of a set of $N$ cells in a periodic unit square domain. Let
$\bfX_i(t)$ denote the position of the $i$th particle in $\Omega \subset \mathbb R^2$.
For each particle $i$, the motion through space is described by a stochastic
differential equation (SDE).


$$
\ud \bfX_i(t) = \sqrt{2 D_\alpha} \ud {\bf W}_i(t) - \sum_{j\ne i} \nabla_i u(\| \bfX_i(t) - \bfX_j(t) \|) \ud t,
$$

where $D=1$ is the diffusion coefficient of the cells, and $\nabla_i$ denotes the
gradient with respect to $\bfX_i$. The interaction potential $u$ may be a soft potential
incorporating effects such as size exclusion by cells and cell-cell adhesion. In this
case we use the soft exponential potential.

The simple method to numerically integrate the SDE is to use a fixed time-step $\Delta 
t$ and a Euler--Maruyama discretisation, resulting in the time-stepping scheme:

$$ 
\bfX_i(t+ \Delta t) = \bfX_i(t) + \sqrt{2D_\alpha \Delta t} \xi_i - \sum_{j\ne i} \nabla_i u(\| \bfX_i(t)
  - \bfX_j(t) \|) \Delta t, 
$$

where $\xi_i$ is a two-dimensional normally distributed random variable with zero mean
and unit variance.

# Numpy Vectorisation


1. Examine the python code in `src/Simulation.py` and `simulate.py`, which implements
   the cell model described above. Install the code
   using the instructions in the `README.md`, and run it using `python
   simulate.py`.

1. Profile the `Simulation.integrate` function.

1. Vectorise the code in `Simulation.diffusion()`, using only a single call to
   `np.random.randn`. How does this improve the profiled time of this function? What is
   the memory cost of vectorising this code, how does it scale with the number of cells 
   $N$?

1. Vectorise the code in `Simulation.boundaries()`, using the `np.where()` function.
   Again make an estimate of the memory cost involved.

1. Now include interactions in the simulation by setting `sim.calculate_interactions =
   True`. The double loop in `Simulations.interactions()` is now a significant
   computational cost. Vectorise this code so that there are no loops remaining. What is
   the memory cost and how does it scale with the number of cells $N$? How
   many particles can you simulate before your computer runs out of RAM?

# Cython

Cython provides a syntax for adding additional static typing information to a Python 
program, that is then compiled to optimised C/C++ code. It allows you to improve the 
performance of the simulation without the RAM cost of vectorisation.

1. Create a new `cell_model/SimulationCython.pyx` file in the project and import it in 
   the `cell_model/__init__.py` file. Copy the *original* python code from 
   `cell_model/Simulation.py` (i.e. not your vectorised version) and change the name of 
   the class to `SimulationCython`. Update the `setup.py` file for the project so your 
   new class can be compiled by Cython when the project is pip installed. Compile the 
   project and run the cell simulation using the new `SimulationCython.pyx` class. 
   Observe the differences in execution time between the pure python and cython classes, 
   if any.
1. Use the `cython` command directly to generate an annotated code html file. Open this 
   in a browser and browse through the C code generated by cython.
1. Change the `SimulationCython` class to be a cython *extension type*. Make sure you 
   define the type of each class attribute (e.g. `x`, `size`). After you are done 
   observe the changes to the C code generated by cython, as well as any speed-ups you 
   have obtained.
1. The bulk of the computation is done in the `interactions` function. Fully optimise 
   the code generated by this function using `cdef` defined local variables, as well as 
   defining the types of the input arguement `dt`. Once you are satisfied that you 
   havn't introduced any bugs to the code, turn off any unneccessary checking (e.g. 
   bounds checking) using cython's decorators. Try to make sure the annotated code for 
   the `interactions` function is entirely white within the double loop.
1. Compare the execution time between your vectorised Python class and your new cython 
   class. Compare the RAM usage.
